# Authorization Guide

The authorization system uses a pluggable architecture with multiple
authorization strategies that can be combined. Authorizers are evaluated in
priority order, and the first one that grants access allows the request to
proceed.

## üîß Built-in Authorizers

### Token-based Authorization
The `TokenAuthorizer` implements HMAC-based authentication using a shared
secret in combination with the TYPO3 encryption key.

**Constants:**
- `AUTH_HEADER_NAME`: `'X-TYPO3-MONITORING-AUTH'` - The HTTP header name for authentication

#### ‚öôÔ∏è Configuration
1. Set the secret in Extension Configuration:
   ```
   api.secret = your-secure-secret-key
   ```

2. Generate HMAC tokens for your monitoring endpoint.

#### Usage
Include the HMAC token in the `X-TYPO3-MONITORING-AUTH` header:

```bash
curl -H "X-TYPO3-MONITORING-AUTH: your-hmac-token" \
     https://yoursite.com/monitor/health
```

#### Token Generation
The HMAC token is generated by the `\TYPO3\CMS\Core\Crypto\HashService` using
the endpoint path and the configured secret on top of the TYPO3 encryption key
for your instance:

```php
$configuredEndpoint = '/monitor/health';
$additionalSecret = 'your-secret-key';
$typo3HashService->hmac($configuredEndpoint, $additionalSecret)
```

### Admin User Authorization
The `AdminUserAuthorizer` allows access for logged-in TYPO3 backend user.

#### ‚öôÔ∏è Configuration
No configuration required. The authorizer automatically checks if:
- User is logged in to the TYPO3 backend
- User has administrator privileges

#### Usage
1. Log in to the TYPO3 backend as an administrator
2. Access the monitoring endpoint directly in your browser
3. No additional headers or authentication required

#### Priority
The `AdminUserAuthorizer` has the lowest priority (`PHP_INT_MIN`) and serves
as a fallback for development and testing.

## üî® Custom Authorizers

### Basic Custom Authorizer
Create a custom authorizer by implementing the `Authorizer` interface:

```php
<?php

declare(strict_types=1);

namespace My\Extension\Authorization;

use mteu\Monitoring\Authorization\Authorizer;
use Psr\Http\Message\ServerRequestInterface;
use Symfony\Component\DependencyInjection\Attribute\AutoconfigureTag;

#[AutoconfigureTag(tag: 'monitoring.authorizer')]
final class CustomAuthorizer implements Authorizer
{
    public function isAuthorized(ServerRequestInterface $request): bool
    {
        // Your authorization logic here
        return $this->checkCustomAuthentication($request);
    }

    public static function getPriority(): int
    {
        return 100; // Higher priority = checked first
    }

    private function checkCustomAuthentication(
        ServerRequestInterface $request
    ): bool
    {
        // Example: Check custom header
        $authHeader = $request->getHeaderLine('X-Custom-Auth');
        return $authHeader === 'valid-token';
    }
}
```

### IP-based Authorizer
Allow access from specific IP addresses:

```php
<?php

declare(strict_types=1);

namespace My\Extension\Authorization;

use mteu\Monitoring\Authorization\Authorizer;
use Psr\Http\Message\ServerRequestInterface;
use Symfony\Component\DependencyInjection\Attribute\AutoconfigureTag;

#[AutoconfigureTag(tag: 'monitoring.authorizer')]
final class IpBasedAuthorizer implements Authorizer
{
    private const ALLOWED_IPS = [
        '192.168.1.100',
        '10.0.0.50',
        '203.0.113.0/24' // CIDR notation
    ];

    public function isAuthorized(ServerRequestInterface $request): bool
    {
        $clientIp = $this->getClientIp($request);

        foreach (self::ALLOWED_IPS as $allowedIp) {
            if ($this->ipMatches($clientIp, $allowedIp)) {
                return true;
            }
        }

        return false;
    }

    public static function getPriority(): int
    {
        return 200;
    }

    private function getClientIp(ServerRequestInterface $request): string
    {
        // Check for IP from load balancer
        if ($request->hasHeader('X-Forwarded-For')) {
            $forwarded = $request->getHeaderLine('X-Forwarded-For');

            return explode(',', $forwarded)[0];
        }

        // Check for IP from proxy
        if ($request->hasHeader('X-Real-IP')) {
            return $request->getHeaderLine('X-Real-IP');
        }

        // Get IP from server params
        $serverParams = $request->getServerParams();

        return $serverParams['REMOTE_ADDR'] ?? '';
    }

    private function ipMatches(string $ip, string $range): bool
    {
        if (strpos($range, '/') === false) {
            // Single IP
            return $ip === $range;
        }

        // CIDR notation
        [$subnet, $mask] = explode('/', $range);
        $ipLong = ip2long($ip);
        $subnetLong = ip2long($subnet);
        $maskLong = (-1 << (32 - (int)$mask));

        return ($ipLong & $maskLong) === ($subnetLong & $maskLong);
    }
}
```

### Multi-Factor Authorizer
Additionally, you may combine multiple authentication methods:

```php
<?php

declare(strict_types=1);

namespace My\Extension\Authorization;

use mteu\Monitoring\Authorization\Authorizer;
use Psr\Http\Message\ServerRequestInterface;
use Symfony\Component\DependencyInjection\Attribute\AutoconfigureTag;

#[AutoconfigureTag(tag: 'monitoring.authorizer')]
final class MultiFactorAuthorizer implements Authorizer
{
    public function __construct(
        private readonly IpBasedAuthorizer $ipAuthorizer,
        private readonly TokenAuthorizer $tokenAuthorizer
    ) {}

    public function isAuthorized(ServerRequestInterface $request): bool
    {
        // Require both IP and token validation
        return $this->ipAuthorizer->isAuthorized($request) &&
               $this->tokenAuthorizer->isAuthorized($request);
    }

    public static function getPriority(): int
    {
        return 500;
    }
}
```

## üîÑ Authorization Priority
Authorizers are evaluated in priority order (highest to lowest). The first
authorizer that grants access allows the request to proceed.

### Default Priorities
- `AdminUserAuthorizer`: `PHP_INT_MIN` (lowest priority)
- `TokenAuthorizer`: `10` (default priority)
- Custom authorizers: Define your own priority

### Priority Guidelines
- **High Priority (500+)**: Strict security requirements
- **Medium Priority (100-499)**: Standard authentication
- **Low Priority (0-99)**: Fallback methods
- **Lowest Priority (< 0)**: Development/testing only

## ‚öôÔ∏è Configuration

### Service Configuration
Authorizers are automatically registered through the
`#[AutoconfigureTag(tag: 'monitoring.authorizer')]` attribute.

### Manual Service Registration
If needed, you can manually register authorizers:

```yaml
# In Configuration/Services.yaml
services:
  My\Extension\Authorization\CustomAuthorizer:
    tags:
      - name: 'monitoring.authorizer'
        priority: 100
```

### Environment-Specific Authorization
```php
public function isAuthorized(ServerRequestInterface $request): bool
{
    $context = \TYPO3\CMS\Core\Utility\GeneralUtility::getApplicationContext();

    if ($context->isDevelopment()) {
        // More permissive in development
        return true;
    }

    // Strict validation in production
    return $this->validateStrictly($request);
}
```

## üîí Security Considerations

### Best Practices
1. **Use HTTPS**: The extension enforces HTTPS for all requests
2. **Strong Secrets**: Use cryptographically secure random secrets
3. **Token Rotation**: Regularly rotate authentication tokens
4. **IP Restrictions**: Combine with IP-based authorization (not yet implemented)
5. **Audit Logging**: Log all authorization attempts (not yet implemented)

### Secret Management
```php
// Use environment variables for secrets
public function __construct()
{
    $this->secret = getenv['MONITORING_SECRET'] ?? '';

    if ($this->secret === '')) {
        throw new \RuntimeException('Monitoring secret not configured');
    }
}
```

### Rate Limiting
Implement rate limiting to prevent abuse:

```php
public function isAuthorized(ServerRequestInterface $request): bool
{
    $clientIp = $this->getClientIp($request);

    if ($this->isRateLimited($clientIp)) {
        return false;
    }

    return $this->validateAuthentication($request);
}
```

## ‚û°Ô∏è Next Steps
After setting up authorization:

1. [Test the API](api.md)
2. [Create custom providers](providers.md)
3. [Use the backend module](backend.md)
4. [Configure monitoring systems](api.md#monitoring-system-integration)
